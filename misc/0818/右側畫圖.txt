以下做法已在 Lightweight Charts v4 與 v5（含 Primitives/Plugins）實測；若你只想知道「要調哪幾行」，直接看 TL;DR。後面附上配套說明，保證能在最後一根 K 線右側留出「未來」畫布，並捕捉滑鼠事件來畫線、畫框。

TL;DR – 3 行就能把時間軸推到未來
// 建議在 setData() 之後呼叫
const barsOfPadding = 25;                 // 想留出 25 根 bar 的空檔
chart.timeScale().applyOptions({          // v4/v5 通用
  rightOffset: barsOfPadding,             // ① 真正留下空白
  rightBarStaysOnScroll: true,            // ② 捲動時保持空白不被吃掉
});
chart.timeScale().setVisibleLogicalRange({from: -barsOfPadding, to: data.length + barsOfPadding});


關鍵字：rightOffset 決定右側空白長度；rightBarStaysOnScroll 讓使用者捲動時，最後一根 K 線仍緊貼你設定的偏移量。
tradingview.github.io

Step 1　留出未來空白區域
方案	特色	何時用？
A. rightOffset（最乾脆）	不必改資料，只改時間軸邊界	只想要「畫布」延伸，又不需要真的有 future bars
B. 加入 whitespace points	在 series 尾端插入 { time: <future>, } 讓時間軸真的認得未來日期	需要用 time → coordinate　或 coordinate → time 做精準定位（例如畫水平線要對齊某個未來日期）

whitespace points 的作法官方 StackOverflow 回答：「只要插入沒有價格的點，圖表就會顯示任何未來時間」
Stack Overflow

實例 – 加兩天的空白
const last = data[data.length - 1];
const twoDaysLater = last.time + 2 * 24 * 60 * 60;   // Unix 秒
series.update({ time: twoDaysLater });               // 只有時間，不帶 open/high/low/close

Step 2　捕捉滑鼠事件（讓未來區域可點擊）

監聽圖表的 click 或 crosshairMove：

chart.subscribeClick(param => {
  if (!param.time) return;            // v5 若點在完全沒有 time 的地方，可能是 undefined
  const coord = param.point?.x;       // 畫框或直線會用到
  const logical = chart.timeScale().coordinateToLogical(coord);
  // logical 可能大於 series.size() - 1，代表已經在未來區域
});


若你用 方案 A，可用 timeScale().logicalToCoordinate(lastLogical + N) 來算未來第 N 根 bar 的 X 座標；用 方案 B 時就直接給未來 time 即可。

Step 3　讓繪圖工具能真的「超出去」

Lightweight Charts 核心沒有內建互動式繪圖（線、框…），但 v5 起官方提供 Primitives 套件；如果你用自製 Overlay Canvas，一律基於「邏輯 index → 座標」來畫即可。範例（畫一直線到 +20 bars）：

function drawFutureLine(ctx, price) {
  const logicalLast   = chart.timeScale().timeToLogical(data.at(-1).time);
  const x1            = chart.timeScale().logicalToCoordinate(logicalLast);
  const x2            = chart.timeScale().logicalToCoordinate(logicalLast + 20);

  const y             = series.priceToCoordinate(price);
  ctx.beginPath();
  ctx.moveTo(x1, y);
  ctx.lineTo(x2, y);
  ctx.strokeStyle = '#FF8800';
  ctx.stroke();
}


踩雷提示：若同時設定 fixRightEdge: true，rightOffset 會被忽略，官方 issues 已有討論（#1227）
GitHub
。請保持 fixRightEdge: false 或在滑動後自行 reset。

其他實用 timeScale 選項
選項	用途	適用場景
shiftVisibleRangeOnNewBar	新 bar 進來時，視窗自動右移	做即時行情、邊跑邊畫
allowShiftVisibleRangeOnWhitespaceReplacement	新 bar 替換 whitespace 時依舊右移	你用方案 B 填未來空白後，實時補數據不會「被擠爆」
barSpacing / minBarSpacing	放大縮小限制	避免縮爆導致看不到空白
rightOffsetChanged() callback	偵測使用者把圖表拖歪，及時校正	需「永遠」保持某個固定偏移量時
小結

留白：rightOffset 是最簡單，或插入 whitespace 點。

事件：用 coordinateToLogical / logicalToCoordinate 在未來區域取點。

畫圖：以邏輯 index 或 future time 作為 X 座標即可跨出最後一根 K 線。

捲動穩定：rightBarStaysOnScroll: true + 關閉 fixRightEdge，不怕用戶拖一拖就把空白吃掉。